[toc]
# 08 | 事务到底是隔离的还是不隔离的？

## 快照是怎么实现的
`InnoDB` 里面每个事务有一个**唯一**的事务 ID，叫作 `transaction id`。它是在事务开始的时候向 `InnoDB` 的事务系统申请的，是按申请顺序严格递增的。

每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本， 并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据 版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

![](media/15980805596849.jpg)

需要注意的是: 
V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 `undo log` 计算出来的。

## 快照在 MVCC 里是怎么工作的？
一个数据版本，对于一个事务视图来说，除了**自己的更新总是可见**以外，有三种情况：
1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

## 更新逻辑
>更新数据都是先读后写的，而这个读，只能读当前的 值，称为“当前读”（current read）。

### 当前读
除了`update`语句外，`select`语句如果加锁，也是当前读。

```sql
mysql> select k from t where id=1 lock in share mode; 
mysql> select k from t where id=1 for update;
```

## 事务的可重复读的能力是怎么实现的？
可重复读的核心就是一致性读（`consistent read`）；而事务更新数据的时候，只能用当前读。
如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
* 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查 询都共用这个一致性视图；
* 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。