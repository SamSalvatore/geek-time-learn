[toc]
# 02.日志系统：一条SQL更新语句是如何执行的？

## 重要的日志模块：redo log
### 什么是redo log
在Oracle RDBMS环境中，redo log包含专有格式的文件，该文件记录了对数据库所做的所有更改的历史记录。每个重做日志文件都包含重做记录。重做记录（也称为重做条目）包含一组更改向量，每个更改向量描述或表示对数据库中单个块所做的更改。

例如，如果用户更新包含员工相关数据的表中的薪水值，则DBMS会生成一个重做记录，该重做记录包含描述该表的数据段块的更改的更改矢量。如果用户随后提交更新，Oracle将生成另一个重做记录，并为更改分配一个“系统更改号”（SCN）。

### 为什么要用redo log
* 提高写效率
    * redo log 只保存没有刷新到磁盘上的操作内容, 写的是一个**连续的硬盘空间**, 硬盘的顺序读写, 要比4k随机读写快太多了(100倍)
* 保证crash-safe
    * 即使数据库发生异常重启，之前提交的记录都不会丢失
    * 当数据库重启的时候,可以根据redo log恢复之前提交的事务

>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

###  `WAL` 技术
`WAL` 的全称是 `Write-Ahead Logging`，它的关键点就是**先写日志，再写磁盘**，也就是先写粉板，等不忙的时候再写账本。

具体来说，当有一条记录需要更新的时候，`InnoDB` 引擎就会先把记录写到 `redo log`（粉板）里面，并更新内存，这个时候更新就算完成了。同时，`InnoDB` 引擎会**在适当的时候**，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。


redolog也分为redo log buffer 和 redo log file, 当事务commit时，将redo log buffer中的内容刷新到redo log file。即写入数据页之前先讲日志持久化。这可以用于保证事务的持久性。


### InnoDB可以无限追加写吗？
不可以。
InnoDB 的 redo log 是固定大小的。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/10/15970208310652.jpg)

write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，**擦除记录前要把记录更新到数据文件**。

write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。

## 重要的日志模块：binlog
### 什么是binlog
二进制日志记录对数据发生或潜在发生更改的**SQL**语句，并以二进制的形式保存在磁盘中

### 为什么要有binglog
* 因为`redo log` 是 `InnoDB` 引擎特有的日志，而别的引擎没有。
* `redolog`是循环写的，不持久保存，`binlog`的“归档”这个功能，`redolog`是不具备的。


Bin log 用于记录了完整的逻辑记录，所有的逻辑记录在 bin log 里都能找到，所以在备份恢复时，是以 bin log 为基础，通过其记录的完整逻辑操作，备份出一个和原库完整的数据。

>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。


### redo log 和 binglog的区别
* `redo log` 是 `InnoDB` 引擎特有的；`binlog` 是 `MySQL` 的 `Server` 层实现的，所有引擎都可以使用。
* `redo log` 是物理日志，记录的是“在某个数据页上做了什么修改”；`binlog` 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
* `redo log` 是循环写的，空间固定会用完；`binlog` 是可以追加写入的。“追加写”是指 `binlog` 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

### 什么是物理日志，什么是逻辑日志
逻辑日志:
```sql
update table set a = 1 where id = 1;
```

物理日志
```
把第10表空间的第90号页面的偏移量为1024处的值更新为1
```

参考
https://www.jianshu.com/p/fdae2e30b9fa
## 两阶段提交
### 什么是两阶段提交
一般情况下，事务提交涉及redo log 和 binlog。当commit 命令执行时，

先进入commit prepare 阶段，这个阶段事务中新生成的redo log 会被刷到磁盘，并将回滚段置为prepared状态。
commit阶段：innodb释放锁，释放回滚段，设置redo log提交状态，binlog持久化到磁盘，然后存储引擎层提交。

如果redo log写入成功处于prepare阶段，写binlog失败，事务回滚，redo log会回滚到操作之前的状态

### 为什么需要二阶段提交？
这是为了让两份日志之间的逻辑一致。

如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

## 参考资料
* https://segmentfault.com/a/1190000017888478
