[TOC]
# 07. 行锁功过-怎么减少行锁对性能的影响？
## 行锁定义
顾名思义，**行锁就是针对数据表中行记录的锁。**这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

## 行锁支持
MySQL 的行锁是在引擎层由各个引擎自己实现的。
但并不是所有的引擎都支持行锁，比如 `MyISAM` 引擎就不支持行锁。

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，**同一张表上任何时刻只能有一个更新在执行**，这就会影响到业务并发度。**InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。**

## 从两阶段锁说起
### 举个例子
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/22/15980823148215.jpg)

事务 `B` 的 `update` 语句会被阻塞，直到事务 `A` 执行 `commit`之后，事务 `B` 才能继续执行。

### 两阶段锁协议
在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

## 死锁和死锁检测
当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/22/15980839816432.jpg)

解决方案：
1、通过参数 innodb_lock_wait_timeout 根据实际业务场景来设置超时时间，InnoDB引擎默认值是50s。
2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）。

innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。