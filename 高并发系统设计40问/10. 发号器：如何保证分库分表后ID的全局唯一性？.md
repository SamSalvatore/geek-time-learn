[TOC]
# 10. 发号器：如何保证分库分表后ID的全局唯一性？

## 回顾
分布式存储核心问题
* 数据冗余
* 数据分片

如何解决
* 主从分离
* 分库分表

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/31/15988363245789.jpg)


带来挑战
* 数据库主键的全局唯一性问题

## 数据库的主键要如何选择？
* 使用业务字段作为主键（不推荐）
* 使用生成的唯一 `ID` 作为主键。（更推荐）

当我们分库分表之后，同一个逻辑表的数据被分布到多个库中，这时如果使用数据库自增字段作为主键，那么只能保证在这个库中是唯一的，无法保证全局的唯一性。

那么假如你来设计用户系统的时候，使用自增 `ID` 作为用户 ID，就可能出现两个用户有两个相同 的 `ID`，这是不可接受的，那么你要怎么做呢？我建议你搭建发号器服务来生成全局唯一的 `ID`。

## 基于 Snowflake 算法搭建发号器
### 为什么不使用UUID
* UUID无法保证有序
    * 无法满足排序等业务需求
    * 影响数据库写入性能
* 不具备业务含义
* `UUID` 由`32`个`16`进制数字组成的字符串，如果作为数据库主键使用比较耗费空间。    

### Snowflake算法介绍
`Snowflake`算法由`Twitter`提出。其核心思想是将 `64bit` 的二进制数字分成若干部分，每一部分都存储有特定含义的数据，比如说时间戳、机器ID、序列号等等，最终生成全局唯一的有序`ID`。

### Snowflake算法实现
![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/31/15988367418585.jpg)

比如:
1 位兼容位恒为 0 + 41 位时间信 息 + 6 位 IDC 信息（支持 64 个 IDC）+ 6 位业务信息（支持 64 个业务）+ 10 位自增信 息（每毫秒支持 1024 个号）

### Snowflake算法工程化
#### 一种是嵌入到业务代码里，也就是分布在业务服务器中。

这种方案的好处是业务代码在使用的时候不需要跨网络调用，性能上会好一些，但是就需要更多的机器 ID 位数来支持更多的 业务服务器。另外，由于业务服务器的数量很多，我们很难保证机器 ID 的唯一性，所以就 需要引入 ZooKeeper 等分布式一致性组件来**保证每次机器重启时都能获得唯一的机器 ID**。

#### 另外一个部署方式是作为独立的服务部署，这也就是我们常说的发号器服务。
业务在使用发号器的时候就需要多一次的网络调用，但是内网的调用对于性能的损耗有限，却可以减少机器`ID`的位数。

如果发号器以主备方式部署，同时运行的只有一个发号器，那么机器 ID 可以省略，这样可以留更多的位数给最后的自增信息位。

即使需要机器 ID，因为发号器部署实例数有限，那么就可以把机器 ID 写在发号器的配置文件里，这样即可以保证机器 ID 唯一性，也无需引入第三方组件了。微博和美图都是使用独立服务的方式来部署发号器的，性能上单实例单CPU 可以达到两万每秒。

### Snowflake算法的缺点
它依赖于系统的时间戳，一旦系统时间不准，就有可能生成重复的 ID。

解决办法: 
* 如果我们发现系统时钟不准，就可以让发号器暂时拒绝发号，直到时钟准确为止。

如果请求发号器的 QPS 不高，比如说发号器每毫秒只发一个 ID，就会造成生成 ID 的末位永远是 1，那么在分库分表时如果使用 ID 作为分区键就会造成库表分配的不均匀。
解决办法主要有两个：
* 时间戳不记录毫秒而是记录秒，这样在一个时间区间里可以多发出几个号，避免出现分库分表时数据分配不均。
* 生成的序列号的起始号可以做一下随机，这一秒是 21，下一秒是 30，这样就会尽量的均衡了。