[TOC]
# 06. 全局锁和表锁

根据加锁的范围，MySQL里面的锁分为
* 全局锁
* 表级锁
* 行锁

## 全局锁
### 概念
对整个数据库实例加锁

### 具体实现
```sql
Flush tables with read lock (FTWRL)
```

### 作用
当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：
* 数据更新语句（数据的增删改）
* 数据定义语句（包括建表、修改表结构等）
* 更新类事务的提交语句。

### 使用场景
* 做全库逻辑备份。也就是把整库每个表都 `select` 出来存成文本。

### 不加锁会有什么问题吗？
不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。

也就是说，两张表的结果可能对不上。

## 表级锁
`MySQL` 里面表级别的锁有两种：
* 表锁
* 元数据锁（meta data lock， `MDL`)。

### 表锁
表锁写法
```sql
lock tables … read/write
```

### MDL
#### 如何使用
MDL 不需要显式使用，**在访问一个表的时候会被自动加上**

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马 上释放，而会等到整个事务提交后再释放。

#### 作用
保证读写的正确性。

你可以想象一下，如果一个查询正在 遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

#### 原理
在 `MySQL 5.5` 版本中引入了 `MDL`，当对一个表做增删改查操作的时候，加 `MDL` 读锁；当要对表做结构变更操作的时候，加 `MDL` 写锁。
* 读锁之间不互斥，因此你可以**有多个线程同时对一张表增删改查。**
* 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。
    * 因此，如果有两个线程要**同时**给一个表加字段，其中一个要等另一个执行完才能开始执行。

#### 容易踩的坑
给表加字段。
不管是大表还是小表，都可能会踩坑。

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/18/15977101821924.jpg)

我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要 的也是 MDL 读锁，因此可以正常执行。

之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 **session C 需要 MDL 写锁，因此只能被阻塞**。

如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁 的请求也会被 session C 阻塞。前面我们说了，**所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住**，等于这个表现在完全不可读写了。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。


为什么session C之后的所有“读”请求都会被阻塞？毕竟session C还没加上锁。难道这里隐含涉及到了意向锁？
> 这个不是读写锁，是锁队列，一进去就开始影响后面的

#### 如何安全地给小表加字段？
* 解决长事务
* 在 `alter table` 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 `MDL` 写锁最好，拿不到 也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过 程。


```sql
ALTER TABLE tbl_name NOWAIT add column ... 
ALTER TABLE tbl_name WAIT N add column ...
```