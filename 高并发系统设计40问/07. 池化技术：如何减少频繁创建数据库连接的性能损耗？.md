[TOC]
# 07. 池化技术：如何减少频繁创建数据库连接的性能损耗？

## 为什么频繁创建连接会造成响应时间慢呢？
以MySQL的连接过程为例,整个MySQL的连接过程可以分为两部分:
* 第一部分是前三个数据包
    * TCP三次握手
* 第二部分是MySQL服务端校验客户端密码的过程

测试结果发现在该试验中，SQL的平均执行时长大概是1ms，而建立连接的过程大概是4ms

## 如何解决上述问题
使用连接池将数据库连接预先建立好，这样在使用的时候就不需要频繁地创建连接了

## 用连接池预先建立数据库连接
数据库连接池有两个最重要的配置：最小连接数和最大连接数。他们控制着从连接池中获取连接的过程:
* 如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
* 如果连接池中有空闲连接则复用空闲连接；
* 如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
* 如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
* 如果等待超过了这个设定时间则向用户抛出错误

为了方便记忆，作者举了一个例子。我觉得挺好的：

-------

假设你在机场里经营着一家按摩椅的小店，店里一共摆着 10 台按摩椅（类比最大连接数），为了节省成本（按摩椅费电），你平时会保持店里开着 4 台按摩椅（最小连接数），其他 6 台都关着。


有顾客来的时候，如果平时保持启动的 4 台按摩椅有空着的，你直接请他去空着的那台就好了。但如果顾客来的时候，4 台按摩椅都不空着，那你就会新启动一台，直到你的 10 台按摩椅都被用完。


那 10 台按摩椅都被用完之后怎么办呢？你会告诉用户，稍等一会儿，我承诺你 5 分钟（等待时间）之内必定能空出来，然后第 11 位用户就开始等着。这时，会有两个结果：如果 5 分钟之内有空出来的，那顾客直接去空出来的那台按摩椅就可以了，但如果用户等了 5 分钟都没空出来，那你就得赔礼道歉，让用户去其他店再看看。

-------

### 参数值的设置
根据作者经验，一般在线上建议最小连接数控制在10左右，最大连接数控制在20～30左右

### 池子中连接的维护问题
一般情况下，“按摩椅故障”的原因可能有以下几种:
* **数据库的域名对应的IP发生了变更**，池子的连接还是使用旧的IP，当旧的IP下的数据库服务关闭后，在使用这个连接查询就会发生错误
* MySQL 有个参数是“wait_timeout”，控制着当数据库连接闲置多长时间后，数据库会主动的关闭这条连接。这个机制对于数据库使用方是无感知的，所以当我们**使用这个被关闭的连接时就会发生错误**

### 如何保证使用的连接都是可用的？
1. （推荐）启动一个线程来定期检测连接池中的连接是否可用，比如使用连接发送`select 1`的命令给数据库看是否会抛出异常，如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。目前 C3P0 连接池可以采用这种方式来检测连接是否可用，也是我比较推荐的方式。
2. 在获取到连接之后，先校验连接是否可用，如果可用才会执行 `SQL` 语句。比如 `DBCP` 连接池的 `testOnBorrow` 配置项，就是控制是否开启这个验证。这种方式在获取连接时会引入多余的开销，在线上系统中还是尽量不要开启，在测试服务上可以使用。

## 用线程池预先创建线程
### 前言
CEO提出了一个新的需求。你分析了一下这个需求，发现在一个非常重要的接口中，你需要访问 3 次数据库。根据经验判断，你觉得这里未来肯定会成为系统瓶颈。

进一步想，你觉得可以创建多个线程来并行处理与数据库之间的交互，这样速度就能快了。不过，因为有了上次数据库的教训，你想到在高并发阶段，频繁创建线程的开销也会很大，于是顺着之前的思路继续想，猜测到了线程池。

### 线程池的执行原理
`JDK 1.5` 中引入的 `ThreadPoolExecutor` 就是一种线程池的实现，它有两个重要的参数：`coreThreadCount` 和 `maxThreadCount`，这两个参数控制着线程池的执行过程。它的执行原理类似上面我们说的按摩椅店的模式
* 如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；
* 如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；
* 当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；
* 当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。

![](http://it-learn.oss-cn-beijing.aliyuncs.com/2020/08/30/15987509461584.jpg)


#### 需要注意的几个地方:
首先。`JDK` 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 `CPU` 密集型的任务，也就是需要执行大量 `CPU` 运算的任务。这是为什么呢？因为执行 `CPU` 密集型的任务时 `CPU` 比较繁忙，因此只需要创建和 `CPU` 核数相当的线程就好了，多了反而会造成**线程上下文切换**，降低任务执行效率。所以当当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。

>但是，我们平时开发的 Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。所以你看 Tomcat 使用的线程池就不是 JDK 原生的线程池，而是做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达 maxThreadCount，这样就比较适合于 Web 系统大量 IO 操作的场景了，你在实际运用过程中也可以参考借鉴。

其次，线程池中使用的队列的堆积量也是我们需要监控的重要指标，对于实时性要求比较高的任务来说，这个指标尤为关键. 如果线程池的 `coreThreadCount` 和 `maxThreadCount` 设置的比较小，导致任务在线程池里面大量的堆积

最后，如果你使用线程池请一定记住不要使用无界队列（即没有设置固定大小的队列）。大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，造成服务不可用。